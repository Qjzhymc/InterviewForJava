1. 熟悉的设计模式说一下应用场景
1.简单工厂模式：如果一个抽象类有多种实现，可以通过一个参数控制需要那种实现这个时候可以加一个工场类，使用工厂类的时候通过对传入参数的判断选择需要哪种类型的实现类。
比如广告调价服务里，不同维度下的广告需要的调价类型不一样，比如有风控，流控，预算控制这些类型。就可以根据广告维度的不同就获取对应的调价方式的实现类。
优点是实现对象的创建和使用分离，将对象的创建交给专门的工厂类，缺点是工厂类不够灵活，增加新的类型的话需要修改工厂类的判断逻辑，如果选择比较多的话，工厂类的代码会比较复杂。
2. 工厂方法模式（重要）：有工厂父类和工厂子类，工厂父类负责定义创建产品对象的公共接口，而工厂子类负责生成具体的产品对象，这样可以将产品类的实例化操作延迟到工厂子类中完成。
优点是增加新的产品类时无需修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；缺点是增加新的产品类时需要增加新的工厂具体类，导致系统中类的个数成对增加，在一定程度上增加了系统的复杂性
3. 抽象工厂模式（重要）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。
4. 建造者模式（生成器模式）：如果一个产品对象有复杂的内部结构，包含多个成员属性，需要生成的产品对象的属性相互依赖，需要指定生成顺序，可以使用建造者模式，一步一步创建一个复杂对象，
允许用户只通过指定复杂对象类型和内容就可以构建他们，用户不需要直到内部具体的构造细节。比如在构建调价候选对象时，需要生成转化数据源，调价数据源，计算方式这些属性，那整个候选对象的创建就是通过一个builder类
来通过传入的维度类型构建一个完整的候选对象的。
5. 单例模式：确保某一个类只有一个实例，而且自行实例化，并向整个系统提供这个实例，这个类就是单例类，它提供全局访问的方法。
构造函数为私有；静态私有成员变量；公有的静态工厂方法；
优点：对于一些需要频繁创建和销毁的对象，提高系统性能。

1.适配器模式：将一个接口转化成希望的另一个接口，可以使一些接口不兼容的类可以一起工作，
2.代理模式：用一个类代表另一个类的功能，为其他对象提供一种代理，以控制对这个对象的访问，比如要直接访问的对象在远程机器上，直接访问会开销很大，或者有一些安全控制，可以在该对象上加一个访问层。比如windows里的
快捷方式，银行存单作为资金的代理，spring aop等

1. 策略模式：不同tagId下会有不同的pipeline，会有不同的广告拉取，过滤，排名，去重，曝光的流程。